/* Twitter ID Card — Single-file React component + serverless snippets

What this package provides (frontend in this file):

"Sign in with Twitter" button that opens an OAuth popup to a serverless endpoint (/api/auth/twitter)

After successful login, frontend fetches /api/user to get the logged-in user's profile (name, username, profile_image_url)

Automatically generates a stylish ID card from the user's profile picture (pfp) using an HTML <canvas>

Ability to download the generated ID card as PNG


Important notes / Setup (read before deploying):

1. You MUST create Twitter (X) developer app credentials and enable OAuth 2.0 Authorization Code Flow. Save TWITTER_CLIENT_ID and TWITTER_CLIENT_SECRET in your Vercel environment variables.


2. This file contains frontend code only. Included below (as commented snippets) are example serverless API routes for Next.js / Vercel (pages/api/*) to handle the OAuth handshake and returning user info.


3. Environment variables required in Vercel:

TWITTER_CLIENT_ID

TWITTER_CLIENT_SECRET

NEXT_PUBLIC_BASE_URL (e.g. https://your-site.vercel.app)

SESSION_SECRET (a random secret for session signing)




Security note: Never expose TWITTER_CLIENT_SECRET on the frontend. Keep it only in serverless env.

How it works (high level):

Frontend calls GET /api/auth/twitter to get the authorization URL and a short-lived state.

Popup opens the authorization URL at Twitter; after user accepts, Twitter redirects to /api/auth/callback which exchanges code for tokens and creates a session (cookie or server-store). Then frontend polls /api/user for profile.


Below you will find:

Frontend React component (default export)

Commented example serverless endpoints for Next.js (copy into pages/api/* in your Next.js project)



---

*/

import React, { useEffect, useRef, useState } from "react";

export default function TwitterIdCardApp() { const [user, setUser] = useState(null); const [loading, setLoading] = useState(false); const [error, setError] = useState(null); const popupRef = useRef(null); const canvasRef = useRef(null);

// when component mounts, check if already logged in useEffect(() => { (async () => { try { const res = await fetch("/api/user"); if (res.ok) { const j = await res.json(); if (j?.user) setUser(j.user); } } catch (e) { // ignore } })(); }, []);

// open popup to serverless auth endpoint const signInWithTwitter = async () => { setError(null); setLoading(true); try { // request an auth URL from the server const res = await fetch("/api/auth/twitter"); if (!res.ok) throw new Error("Gagal membuat request login"); const { url } = await res.json();

// open popup
  const w = 600, h = 700;
  const left = window.screenX + (window.outerWidth - w) / 2;
  const top = window.screenY + (window.outerHeight - h) / 2.5;
  popupRef.current = window.open(url, "twitter_oauth", `width=${w},height=${h},left=${left},top=${top}`);

  // poll for popup closed or session established
  const interval = setInterval(async () => {
    if (!popupRef.current || popupRef.current.closed) {
      clearInterval(interval);
      setLoading(false);
      return;
    }
    // ping server to see if session exists
    try {
      const r = await fetch("/api/user");
      if (r.ok) {
        const j = await r.json();
        if (j?.user) {
          clearInterval(interval);
          setUser(j.user);
          popupRef.current.close();
          setLoading(false);
        }
      }
    } catch (e) {
      // ignore transient errors
    }
  }, 1000);
} catch (e) {
  setError(e.message);
  setLoading(false);
}

};

// generate ID card when user object is available useEffect(() => { if (!user) return; generateIdCard(user); // eslint-disable-next-line react-hooks/exhaustive-deps }, [user]);

async function generateIdCard(user) { const canvas = canvasRef.current; if (!canvas) return; const ctx = canvas.getContext("2d"); // layout const width = 1000; const height = 600; canvas.width = width; canvas.height = height;

// background gradient
const g = ctx.createLinearGradient(0, 0, width, height);
g.addColorStop(0, "#0f172a");
g.addColorStop(1, "#0ea5e9");
ctx.fillStyle = g;
ctx.fillRect(0, 0, width, height);

// decorative rounded card inset
const inset = 40;
roundRect(ctx, inset, inset, width - inset * 2, height - inset * 2, 24);
ctx.fillStyle = "rgba(255,255,255,0.06)";
ctx.fill();

// left area for avatar
const avatarSize = 360;
const avatarX = inset + 40;
const avatarY = (height - avatarSize) / 2;

// fetch avatar image and draw circular crop
const img = await loadImage(rewriteTwitterPfp(user.profile_image_url));
// draw avatar circle with white ring
const cx = avatarX + avatarSize / 2;
const cy = avatarY + avatarSize / 2;
ctx.save();
ctx.beginPath();
ctx.arc(cx, cy, avatarSize / 2 + 8, 0, Math.PI * 2);
ctx.fillStyle = "rgba(255,255,255,0.12)";
ctx.fill();
ctx.beginPath();
ctx.arc(cx, cy, avatarSize / 2, 0, Math.PI * 2);
ctx.closePath();
ctx.clip();
// draw image to fit
ctx.drawImage(img, avatarX, avatarY, avatarSize, avatarSize);
ctx.restore();

// right area: name, username, bio
const rightX = avatarX + avatarSize + 40;
const contentWidth = width - rightX - inset - 40;

// name
ctx.font = "42px Inter, Roboto, system-ui";
ctx.fillStyle = "#ffffff";
ctx.fillText(user.name, rightX, avatarY + 80);

// username
ctx.font = "28px Inter, Roboto, system-ui";
ctx.fillStyle = "#cbd5e1";
ctx.fillText("@" + user.username, rightX, avatarY + 120);

// small stats / badge
ctx.font = "18px Inter, Roboto, system-ui";
ctx.fillStyle = "#94a3b8";
ctx.fillText(`ID · ${user.id}`, rightX, avatarY + 160);

// bio wrapped
ctx.font = "20px Inter, Roboto, system-ui";
ctx.fillStyle = "#e6eef8";
const bio = user.description || "Tidak ada bio";
wrapText(ctx, bio, rightX, avatarY + 200, contentWidth, 28);

// footer flair
ctx.font = "16px Inter, Roboto, system-ui";
ctx.fillStyle = "rgba(255,255,255,0.6)";
ctx.fillText("Generated by Twitter ID Card", rightX, height - inset - 30);

}

function downloadCard() { const c = canvasRef.current; if (!c) return; const url = c.toDataURL("image/png"); const a = document.createElement("a"); a.href = url; a.download = twitter-idcard-${user?.username || "me"}.png; document.body.appendChild(a); a.click(); a.remove(); }

return ( <div className="min-h-screen flex items-center justify-center bg-gradient-to-b from-slate-900 to-slate-800 p-6"> <div className="max-w-4xl w-full bg-white/5 backdrop-blur-md rounded-2xl p-6 shadow-2xl"> <div className="flex items-center justify-between mb-6"> <h1 className="text-2xl font-semibold text-white">Twitter ID Card Generator</h1> <div> {!user ? ( <button
onClick={signInWithTwitter}
className="inline-flex items-center gap-3 px-4 py-2 rounded-lg bg-white text-slate-900 font-medium shadow"
disabled={loading}
> <svg width="20" height="20" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"> <path d="M8 19c7-7 11-12 11-17-1 1-3 2-4 2 2-2 3-5 3-7-2 2-5 4-7 5C8 4 6 1 4 0c1 2 4 4 7 5C6 7 4 9 3 12c1-1 3-2 5-2-1 2-1 4 0 6z" fill="#1DA1F2" /> </svg> {loading ? "Loading..." : "Sign in with Twitter"} </button> ) : ( <div className="flex items-center gap-3"> <img src={rewriteTwitterPfp(user.profile_image_url)} alt="pfp" className="w-10 h-10 rounded-full" /> <div className="text-sm text-slate-200"> <div className="font-semibold">{user.name}</div> <div className="text-slate-400">@{user.username}</div> </div> </div> )} </div> </div>

<div className="grid grid-cols-1 md:grid-cols-2 gap-6">
      <div className="p-4 rounded-xl bg-white/3 flex flex-col items-center justify-center">
        <canvas ref={canvasRef} className="rounded-md shadow" style={{ maxWidth: '100%' }} />
      </div>

      <div className="p-4 rounded-xl bg-white/3">
        <h2 className="text-lg text-white font-medium mb-2">Preview & Actions</h2>
        <p className="text-sm text-slate-300 mb-4">Setelah login, kartu identitas akan otomatis ter-generate dari foto profil Twitter kamu.</p>

        <div className="flex gap-3">
          <button
            onClick={downloadCard}
            disabled={!user}
            className="px-4 py-2 rounded-lg bg-sky-500 text-white font-medium disabled:opacity-50"
          >
            Download PNG
          </button>

          <button
            onClick={() => { if (user) generateIdCard(user); }}
            disabled={!user}
            className="px-4 py-2 rounded-lg bg-white text-slate-900 font-medium disabled:opacity-50"
          >
            Regenerate
          </button>
        </div>

        {error && <div className="mt-4 text-sm text-red-400">{error}</div>}
      </div>
    </div>

    <div className="mt-6 text-sm text-slate-400">Tip: Untuk kualitas avatar terbaik, gunakan profil Twitter yang bukan gambar low-res.</div>
  </div>
</div>

); }

/* --------------------- Helper functions --------------------- */

function roundRect(ctx, x, y, w, h, r) { ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath(); }

function wrapText(ctx, text, x, y, maxWidth, lineHeight) { const words = text.split(' '); let line = ''; for (let n = 0; n < words.length; n++) { const testLine = line + words[n] + ' '; const metrics = ctx.measureText(testLine); const testWidth = metrics.width; if (testWidth > maxWidth && n > 0) { ctx.fillText(line, x, y); line = words[n] + ' '; y += lineHeight; } else { line = testLine; } } ctx.fillText(line, x, y); }

function loadImage(src) { return new Promise((resolve, reject) => { const img = new Image(); img.crossOrigin = 'anonymous'; img.onload = () => resolve(img); img.onerror = (e) => reject(e); img.src = src; }); }

// Twitter serves small avatar by default ending with '_normal'. Replace with higher-res version. function rewriteTwitterPfp(url) { if (!url) return url; return url.replace('_normal', '_400x400'); }

/* --------------------- Example serverless snippets --------------------- Copy the following into your Next.js project under /pages/api/...

// pages/api/auth/twitter.js import fetch from 'node-fetch'; export default async function handler(req, res) { // This endpoint initiates OAuth flow: build Twitter authorization URL and redirect there. // Implementation outline (server-side): // 1) build PKCE code_verifier + code_challenge (optional but recommended) // 2) set a random state in a httpOnly cookie // 3) construct authorization url with client_id, redirect_uri, scope, state, code_challenge if used // 4) return { url }

const TWITTER_CLIENT_ID = process.env.TWITTER_CLIENT_ID; const BASE = process.env.NEXT_PUBLIC_BASE_URL || 'http://localhost:3000'; const redirect_uri = ${BASE}/api/auth/callback; const state = Math.random().toString(36).slice(2); // store state in cookie res.setHeader('Set-Cookie', oauth_state=${state}; HttpOnly; Path=/; Max-Age=300; SameSite=Lax); const params = new URLSearchParams({ response_type: 'code', client_id: TWITTER_CLIENT_ID, redirect_uri, scope: 'tweet.read users.read offline.access', state, code_challenge: 'challenge', // implement proper PKCE code_challenge_method: 'plain' }); res.status(200).json({ url: https://twitter.com/i/oauth2/authorize?${params.toString()} }); }

// pages/api/auth/callback.js import fetch from 'node-fetch'; export default async function handler(req, res) { // Twitter will redirect here with ?code=...&state=... // Steps: // 1) verify state matches stored cookie // 2) exchange code for access token by POST to https://api.twitter.com/2/oauth2/token // 3) use token to fetch user info: https://api.twitter.com/2/users/me?user.fields=profile_image_url,description // 4) create a session (cookie) for the user and redirect to your app (e.g. /)

const { code, state } = req.query; const stored = req.cookies['oauth_state']; if (!code || !state || state !== stored) { return res.status(400).send('Invalid OAuth state'); }

// exchange code for token (example, not complete — follow Twitter's docs exactly) // store tokens if you need offline access

// after getting user info, create an httpOnly cookie with a session id or jwt and redirect to '/' res.setHeader('Set-Cookie', session=1; HttpOnly; Path=/; Max-Age=86400; SameSite=Lax); res.redirect('/'); }

// pages/api/user.js export default async function handler(req, res) { // Example: read session cookie / verify jwt, and return user profile stored server-side // For demo, return a mock if session exists const session = req.cookies['session']; if (!session) return res.status(401).json({ error: 'not_authenticated' }); // In real app, fetch from DB or in-memory store // Sample shape returned by Twitter v2 user object: // { id, name, username, profile_image_url, description } const sample = { id: '1234567', name: 'Demo User', username: 'demo', profile_image_url: 'https://abs.twimg.com/sticky/default_profile_images/default_profile_400x400.png', description: 'This is a demo user.' }; res.status(200).json({ user: sample }); }

--------------------- End serverless snippets --------------------- */